<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Israel Coffee â€” Boss Fight Bullet Hell</title>
<style>
  :root{--bg:#0b1020;--fg:#e6eef8;--accent:#ff6b6b;}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071020,#0b1020);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #gameWrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:12px}
  canvas{background:linear-gradient(180deg,#071020,#071930);border:6px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(0,0,0,0.6);}
  .ui{width:900px;max-width:calc(100vw - 24px);display:flex;justify-content:space-between;align-items:center}
  .hud{display:flex;gap:12px;align-items:center}
  .bar{height:18px;border-radius:8px;background:rgba(255,255,255,0.06);padding:2px;min-width:220px}
  .bar > .fill{height:100%;border-radius:6px;background:linear-gradient(90deg,var(--accent),#ffb86b);width:100%}
  .small{font-size:12px;color:#9fb0c9}
  .center{display:flex;gap:12px;align-items:center}
  button{background:#132235;color:var(--fg);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px}
  @media (max-width:700px){.ui{flex-direction:column;align-items:flex-start}}
</style>
</head>
<body>
<div id="gameWrap">
  <div class="ui">
    <div class="hud">
      <div>
        <div class="small">Player</div>
        <div class="bar" style="width:180px"><div id="playerHP" class="fill" style="width:100%"></div></div>
      </div>
      <div>
        <div class="small">Boss: Israel Coffee</div>
        <div class="bar"><div id="bossHP" class="fill" style="width:100%"></div></div>
      </div>
    </div>
    <div class="center small">
      <div>WASD: Move</div>
      <div>Space: Jump</div>
      <div>Hold LMB: Swing</div>
      <div>Aim: Mouse</div>
    </div>
  </div>
  <canvas id="c" width="900" height="600"></canvas>
  <div style="width:900px;max-width:calc(100vw - 24px);display:flex;justify-content:space-between;align-items:center">
    <div class="small">Tip: The sword hits in an arc around your aim. Timing matters!</div>
    <div><button id="restart">Restart</button></div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width; const H = canvas.height;

  // Game state
  let keys = {};
  let mouse = {x: W/2, y: H/2, down:false};

  // Player
  const player = {
    x: W/2, y: H - 120, w:28, h:48,
    vx:0, vy:0, speed:230, onGround:false,
    hp:100, maxHp:100,
    facing:1
  };

  // Boss: Israel Coffee
  const boss = {
    x: W/2, y:120, r:60,
    vx:60, hp:500, maxHp:500,
    phase:1, time:0, alive:true
  };

  // Bullets
  let bullets = [];

  // Sword swing
  const sword = {
    sweeping:false, // whether currently attacking
    timer:0, // how long into swing
    swingTime:0.18, // seconds for one swing cycle
    arc:Math.PI * 0.9, // arc size (radians)
    range:90, // pixels
    cooldown:0.06 // damage tick
  };

  let lastTime = performance.now();
  let accum = 0;

  // Helpers
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function lerp(a,b,t){return a + (b-a)*t}

  // Input
  window.addEventListener('keydown', e => {keys[e.key.toLowerCase()]=true; if(e.key===' '){e.preventDefault();}});
  window.addEventListener('keyup', e => {keys[e.key.toLowerCase()]=false;});
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });
  canvas.addEventListener('mousedown', e => { if(e.button===0) mouse.down = true; });
  canvas.addEventListener('mouseup', e => { if(e.button===0) mouse.down = false; });

  document.getElementById('restart').addEventListener('click', resetGame);

  function resetGame(){
    player.x = W/2; player.y = H-120; player.vx = player.vy = 0; player.hp = player.maxHp; boss.hp = boss.maxHp; boss.x = W/2; boss.vx = 60; boss.phase = 1; boss.time=0; boss.alive=true; bullets=[]; sword.timer=0; sword.sweeping=false;
  }

  // Bullet creation
  function spawnBullet(x,y,vx,vy,size=6,owner='boss',life=6){ bullets.push({x,y,vx,vy,size,owner,life}); }

  // Boss patterns
  function bossUpdate(dt){
    boss.time += dt;
    // simple horizontal movement
    boss.x += boss.vx * dt;
    if(boss.x < boss.r + 20){ boss.x = boss.r + 20; boss.vx *= -1; }
    if(boss.x > W - boss.r - 20){ boss.x = W - boss.r - 20; boss.vx *= -1; }

    // change phase by health
    const hpPct = boss.hp / boss.maxHp;
    boss.phase = hpPct > 0.6 ? 1 : hpPct > 0.33 ? 2 : 3;

    // firing patterns depending on phase
    if(boss.phase === 1){
      // slow radial burst every 1.2s
      if(Math.floor(boss.time * 10) % 12 === 0 && (boss.time - dt) * 10 % 12 > (boss.time * 10) % 12 - 1){
        radial(boss.x, boss.y, 12, 120);
      }
    } else if(boss.phase === 2){
      // spiral and aimed
      if(Math.floor(boss.time * 20) % 6 === 0){
        spiral(boss.x, boss.y, boss.time*8, 8, 180);
      }
      if(Math.random() < dt * 1.2){ // occasional aimed shots
        aimed(boss.x, boss.y, player.x, player.y, 220);
      }
    } else {
      // intense: homing bullets and large radial
      if(Math.floor(boss.time * 8) % 8 === 0){ radial(boss.x, boss.y, 20, 160); }
      if(Math.random() < dt * 2.0){ homing(boss.x, boss.y, player, 140); }
    }

    // if boss dies
    if(boss.hp <= 0 && boss.alive){ boss.alive=false; setTimeout(()=>{/* nothing */},500); }
  }

  function radial(x,y,count,speed){
    for(let i=0;i<count;i++){
      const a = (i / count) * Math.PI*2 + Math.random()*0.12;
      spawnBullet(x, y, Math.cos(a)*speed, Math.sin(a)*speed, 6, 'boss', 8);
    }
  }
  function spiral(x,y,phase,step,speed){
    for(let i=0;i<step;i++){
      const a = phase + i * (Math.PI*2 / step);
      spawnBullet(x,y,Math.cos(a)*speed,Math.sin(a)*speed,5,'boss',7);
    }
  }
  function aimed(x,y,tx,ty,speed){
    const ang = Math.atan2(ty-y, tx-x);
    spawnBullet(x,y,Math.cos(ang)*speed,Math.sin(ang)*speed,7,'boss',6);
  }
  function homing(x,y,target,speed){
    // spawn a slower bullet that steers
    spawnBullet(x,y, (target.x - x)/100 * speed, (target.y - y)/100 * speed, 8, 'boss', 9);
  }

  // collision helper
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

  // Game update
  function update(dt){
    // Player movement
    let moveX = 0;
    if(keys['a']) moveX -= 1;
    if(keys['d']) moveX += 1;
    player.vx = lerp(player.vx, moveX * player.speed, 0.16);

    // Jump
    if((keys['w'] || keys[' ']) && player.onGround){ player.vy = -420; player.onGround=false; }

    // Apply gravity
    player.vy += 1200 * dt;

    // Integrate position
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // ground collision
    const groundY = H - 60;
    if(player.y + player.h/2 > groundY){ player.y = groundY - player.h/2; player.vy = 0; player.onGround = true; }

    // keep inside
    player.x = clamp(player.x, 30, W-30);

    // update facing based on mouse
    player.facing = (mouse.x >= player.x) ? 1 : -1;

    // Sword handling
    if(mouse.down){
      // begin sweep
      if(!sword.sweeping) { sword.sweeping = true; sword.timer = 0; }
      sword.timer += dt;
    } else {
      sword.sweeping = false; sword.timer = 0;
    }

    // boss
    if(boss.alive) bossUpdate(dt);

    // bullets movement
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      // simple homing for homing bullets by owner 'boss' with life>7
      if(b.owner==='boss' && b.life>8){
        const ang = Math.atan2(player.y - b.y, player.x - b.x);
        const sp = Math.hypot(b.vx, b.vy);
        // steer slightly
        const desiredVx = Math.cos(ang)*sp;
        const desiredVy = Math.sin(ang)*sp;
        b.vx = lerp(b.vx, desiredVx, 0.06);
        b.vy = lerp(b.vy, desiredVy, 0.06);
      }
      b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
      // remove offscreen or dead
      if(b.life <= 0 || b.x < -50 || b.x > W+50 || b.y < -50 || b.y > H+50) bullets.splice(i,1);
    }

    // Bullet collisions with player
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      if(b.owner==='boss'){
        const dx = player.x - b.x; const dy = player.y - b.y;
        const rad = Math.hypot(dx,dy);
        if(rad < (b.size + Math.max(player.w, player.h)/2 - 4)){
          // take damage
          player.hp -= 6;
          bullets.splice(i,1);
          // small knockback
          player.vx += dx/rad * -120;
        }
      }
    }

    // Sword hit boss detection when sweeping
    if(sword.sweeping && boss.alive){
      // compute aim angle
      const aimAng = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      // swing progress loops to create repeated hits while held
      const swingsPerSec = 1 / Math.max(0.08, sword.swingTime);
      // compute current swing phase using timer
      const phase = (sword.timer % sword.swingTime) / sword.swingTime; // 0..1
      // map to angular offset to create a back-and-forth swing
      const halfArc = sword.arc/2;
      // we'll move angle from aim - halfArc/2 to aim + halfArc/2
      const currentAngle = aimAng - halfArc/2 + halfArc * phase;
      const dx = boss.x - player.x; const dy = boss.y - player.y; const d = Math.hypot(dx,dy);
      if(d < sword.range + boss.r){
        const angToBoss = Math.atan2(dy,dx);
        let diff = Math.abs(((angToBoss - currentAngle) + Math.PI) % (Math.PI*2) - Math.PI);
        if(diff < 0.55){
          // hit boss
          // to prevent continuous HP drain too fast, tie damage to cooldown timer
          if(!sword._lastHitTime || performance.now() - sword._lastHitTime > sword.cooldown*1000){
            sword._lastHitTime = performance.now();
            boss.hp -= 12; // damage
            // small knockback
            boss.x += Math.cos(currentAngle) * 6;
            // spawn particles
            for(let i=0;i<6;i++){
              const a = currentAngle + (Math.random()-0.5)*0.8;
              spawnBullet(boss.x, boss.y, Math.cos(a)*(60+Math.random()*80), Math.sin(a)*(60+Math.random()*80), 3, 'player', 0.5);
            }
          }
        }
      }
    }

    // Boss contact with player
    const dxBP = boss.x - player.x; const dyBP = boss.y - player.y; if(Math.hypot(dxBP,dyBP) < boss.r + 20){
      // colliding
      player.hp -= 0.8;
    }

    // clamp hp
    player.hp = clamp(player.hp, 0, player.maxHp);
    boss.hp = clamp(boss.hp, 0, boss.maxHp);
  }

  // Draw
  function draw(){
    ctx.clearRect(0,0,W,H);

    // background stars
    for(let i=0;i<40;i++){
      const sx = (i*97) % W; const sy = ((i*47) + (performance.now()/60|0)) % H;
      ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(sx,sy,1.2,1.2);
    }

    // ground
    ctx.fillStyle = '#071a29'; ctx.fillRect(0,H-60,W,60);
    // decorative platforms
    ctx.fillStyle = '#0d2a3a'; ctx.fillRect(80,H-180,220,12);
    ctx.fillRect(W-320,H-260,200,12);

    // draw boss
    if(boss.alive){
      // boss body
      const g = ctx.createLinearGradient(boss.x - boss.r, boss.y - boss.r, boss.x + boss.r, boss.y + boss.r);
      g.addColorStop(0,'#6b2d2d'); g.addColorStop(1,'#ff8b5e');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.ellipse(boss.x,boss.y,boss.r,boss.r*0.85,0,0,Math.PI*2); ctx.fill();
      // boss eyes / features
      ctx.fillStyle = '#2b0d0d'; ctx.beginPath(); ctx.ellipse(boss.x-18,boss.y-6,10,8,0,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(boss.x+18,boss.y-6,10,8,0,0,Math.PI*2); ctx.fill();
      // boss name label
      ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = '16px system-ui'; ctx.textAlign='center'; ctx.fillText('Israel Coffee', boss.x, boss.y - boss.r - 18);
    } else {
      // explosion
      ctx.fillStyle = 'rgba(255,220,80,0.14)'; ctx.beginPath(); ctx.ellipse(boss.x,boss.y, boss.r*1.6, boss.r*1.2,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = 'white'; ctx.font='30px system-ui'; ctx.textAlign='center'; ctx.fillText('DEFEATED', boss.x, boss.y);
    }

    // draw bullets
    for(const b of bullets){
      if(b.owner === 'boss'){
        ctx.fillStyle = 'rgba(255,90,90,0.98)';
        ctx.beginPath(); ctx.arc(b.x,b.y,b.size,0,Math.PI*2); ctx.fill();
      } else {
        ctx.fillStyle = 'rgba(180,220,255,0.98)'; ctx.beginPath(); ctx.arc(b.x,b.y,b.size,0,Math.PI*2); ctx.fill();
      }
    }

    // draw player
    ctx.save();
    ctx.translate(player.x, player.y);
    // body
    ctx.fillStyle = '#a8d3ff'; ctx.beginPath(); ctx.rect(-player.w/2, -player.h/2, player.w, player.h); ctx.fill();
    // head
    ctx.fillStyle = '#f7f7f7'; ctx.beginPath(); ctx.arc(10, -player.h/2 + 8, 8, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // draw sword arc when sweeping
    if(sword.sweeping){
      const aimAng = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      const halfArc = sword.arc/2;
      const phase = (sword.timer % sword.swingTime) / sword.swingTime;
      const currentAngle = aimAng - halfArc/2 + halfArc * phase;
      // visual arc
      ctx.save(); ctx.translate(player.x, player.y);
      ctx.strokeStyle = 'rgba(255,240,200,0.12)'; ctx.lineWidth = 36; ctx.beginPath(); ctx.arc(0,0, sword.range, currentAngle - 0.45, currentAngle + 0.45); ctx.stroke();
      ctx.strokeStyle = 'rgba(255,220,120,0.4)'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0,0, sword.range, currentAngle - 0.45, currentAngle + 0.45); ctx.stroke();
      // sword tip
      const tipX = Math.cos(currentAngle) * sword.range; const tipY = Math.sin(currentAngle) * sword.range;
      ctx.fillStyle = 'rgba(255,240,180,0.95)'; ctx.beginPath(); ctx.arc(tipX, tipY, 8, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    } else {
      // show small aim reticle
      ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.arc(mouse.x, mouse.y, 8, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.arc(mouse.x, mouse.y, 18, 0, Math.PI*2); ctx.stroke();
    }

    // HUD updates
    document.getElementById('playerHP').style.width = (player.hp / player.maxHp * 100) + '%';
    document.getElementById('bossHP').style.width = (boss.hp / boss.maxHp * 100) + '%';

    // player HP text
    ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='14px system-ui'; ctx.textAlign='left'; ctx.fillText('HP: ' + Math.round(player.hp), 12, 20);

    // show boss status
    if(!boss.alive){ ctx.fillStyle='rgba(180,255,200,0.9)'; ctx.font='18px system-ui'; ctx.textAlign='center'; ctx.fillText('You defeated Israel Coffee! Nice!', W/2, 50); }

    // Game over
    if(player.hp <= 0){ ctx.fillStyle='rgba(255,120,120,0.95)'; ctx.font='36px system-ui'; ctx.textAlign='center'; ctx.fillText('YOU DIED', W/2, H/2); }
  }

  // main loop
  function loop(now){
    const dt = Math.min(1/30, (now - lastTime)/1000);
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

})();

// --- Added enhancements: Phase 2, minions, attacks, jump boost ---

// Increase jump height
if (typeof JUMP_FORCE !== 'undefined') {
  JUMP_FORCE = 18;
}

// Ensure boss object has phase flags
if (typeof boss !== 'undefined') {
  boss.phase2 = boss.phase2 || false;
  boss.summonCooldown = boss.summonCooldown || 2000;
  boss.lastSummon = boss.lastSummon || 0;
}

// Minion summoning function
function summonMinion() {
  enemies.push({
    x: boss.x,
    y: boss.y,
    vx: 0,
    vy: 0,
    speed: 2.2,
    width: 40,
    height: 40,
    melee: true,
    sprite: 'gubby.png'
  });
}

// Boss update wrapper
const _oldBossUpdate = updateBoss;
updateBoss = function() {
  _oldBossUpdate();

  // Trigger Phase 2
  if (!boss.phase2 && boss.health < boss.maxHealth * 0.5) {
    boss.phase2 = true;
    boss.color = 'red';
    boss.attackCooldown *= 0.6;
  }

  // Phase 2 minion spawning
  if (boss.phase2) {
    const now = performance.now();
    if (now - boss.lastSummon > boss.summonCooldown) {
      summonMinion();
      summonMinion();
      boss.lastSummon = now;
    }
  }
};

// Add extra rapid-fire projectiles in phase 2
const _oldBossAttack = spawnBossAttack;
spawnBossAttack = function() {
  _oldBossAttack();

  if (boss.phase2) {
    setTimeout(_oldBossAttack, 200);
    setTimeout(_oldBossAttack, 400);
  }
};

// --- End enhancements ---

</script>
</body>
</html>
