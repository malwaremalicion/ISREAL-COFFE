<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Israel Coffee â€” Boss Fight Bullet Hell</title>
<style>
  :root{--bg:#0b1020;--fg:#e6eef8;--accent:#ff6b6b;}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071020,#0b1020);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #gameWrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:12px}
  canvas{background:linear-gradient(180deg,#071020,#071930);border:6px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(0,0,0,0.6);}
  .ui{width:900px;max-width:calc(100vw - 24px);display:flex;justify-content:space-between;align-items:center}
  .hud{display:flex;gap:12px;align-items:center}
  .bar{height:18px;border-radius:8px;background:rgba(255,255,255,0.06);padding:2px;min-width:220px}
  .bar > .fill{height:100%;border-radius:6px;background:linear-gradient(90deg,var(--accent),#ffb86b);width:100%}
  .small{font-size:12px;color:#9fb0c9}
  .center{display:flex;gap:12px;align-items:center}
  button{background:#132235;color:var(--fg);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px}
  @media (max-width:700px){.ui{flex-direction:column;align-items:flex-start}}
  /* main menu styling */
  #mainMenu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:linear-gradient(180deg,#071020cc,#071930cc);z-index:50;color:var(--fg);}
  #mainMenu button{cursor:pointer}
</style>
</head>
<body>
<div id="mainMenu">
  <div style="font-size:28px;text-align:center;padding:8px 16px;">I AM IS REAL COFFEE PT BOME GAH ZAH</div>
  <button id="startBtn" style="margin-top:18px;padding:10px 20px;font-size:18px;border-radius:8px;">Start</button>
</div>

<div id="gameWrap" style="visibility:visible">
  <div class="ui">
    <div class="hud">
      <div>
        <div class="small">Player</div>
        <div class="bar" style="width:180px"><div id="playerHP" class="fill" style="width:100%"></div></div>
      </div>
      <div>
        <div class="small">Boss: Israel Coffee</div>
        <div class="bar"><div id="bossHP" class="fill" style="width:100%"></div></div>
      </div>
    </div>
    <div class="center small">
      <div>WASD: Move</div>
      <div>Space: Jump</div>
      <div>Hold LMB: Swing</div>
      <div>Aim: Mouse</div>
    </div>
  </div>
  <canvas id="c" width="900" height="600"></canvas>
  <div style="width:900px;max-width:calc(100vw - 24px);display:flex;justify-content:space-between;align-items:center">
    <div class="small">Tip: The sword hits in an arc around your aim. Timing matters!</div>
    <div><button id="restart">Restart</button></div>
  </div>
</div>

<script>
/*
  Cleaned, unified game file.
  - Start button hides menu and starts the game loop.
  - Sprites load properly (fallbacks to rectangles if missing).
  - Phase 2, minions (gubby.png), and laser integrated.
  - Page reloads shortly after player death.
*/

// --- Assets ---
const bossImg = new Image();
bossImg.src = 'boss.png'; // place boss.png next to the HTML (or change path)

const playerImg = new Image();
playerImg.src = 'player.png'; // place player.png next to the HTML

const gubbyImg = new Image();
gubbyImg.src = 'gubby.png'; // place gubby.png next to the HTML

// --- Canvas & basic state ---
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let running = false; // game loop runs only after Start pressed

// Input
let keys = {};
let mouse = {x: W/2, y: H/2, down:false};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key === ' ') e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
  mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
});
canvas.addEventListener('mousedown', e => { if(e.button === 0) mouse.down = true; });
canvas.addEventListener('mouseup', e => { if(e.button === 0) mouse.down = false; });

// restart button reloads
document.getElementById('restart').addEventListener('click', () => location.reload());

// --- Player ---
const player = {
  x: W/2, y: H - 120, w: 28, h: 48,
  vx: 0, vy: 0, speed: 230, onGround: false,
  hp: 1000, maxHp: 1000, facing: 1
};

// --- Boss ---
const boss = {
  x: W/2, y: 120, r: 60,
  vx: 60, hp: 500, maxHp: 500,
  phase: 1, time: 0, alive: true,
  // laser/minion defaults
  phase2: false, summonCooldown: 2500, lastSummon: 0,
  laserActive: false, laserTimer: 0, laserDuration: 1.2, laserWindup: 0.5, laserCooldown: 4.0, _sinceLastLaser: 0
};
let laser = { ang: 0, scale: 1 };

// Platforms
const platforms = [
  {x:80, y:H-180, w:220, h:12},
  {x:W-320, y:H-260, w:200, h:12},
  {x:W/2-150, y:H-330, w:300, h:12},
  {x:50, y:H-400, w:220, h:12},
  {x:W-270, y:H-430, w:240, h:12}
];

// bullets, enemies
let bullets = [];
let enemies = [];

// sword
const sword = { sweeping:false, timer:0, swingTime:0.18, arc:Math.PI * 0.9, range:90, cooldown:0.06, _lastHitTime:0 };

// timing
let lastTime = 0;

// helpers
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t) => a + (b-a) * t;

// spawn bullet helper
function spawnBullet(x,y,vx,vy,size=6,owner='boss',life=6){
  bullets.push({x,y,vx,vy,size,owner,life});
}

// bullet patterns
function radial(x,y,count,speed){
  for(let i=0;i<count;i++){
    const a = (i / count) * Math.PI*2 + (Math.random()-0.5)*0.12;
    spawnBullet(x, y, Math.cos(a)*speed, Math.sin(a)*speed, 6, 'boss', 8);
  }
}
function spiral(x,y,phase,step,speed){
  for(let i=0;i<step;i++){
    const a = phase + i * (Math.PI*2 / step);
    spawnBullet(x,y,Math.cos(a)*speed,Math.sin(a)*speed,5,'boss',7);
  }
}
function aimed(x,y,tx,ty,speed){
  const ang = Math.atan2(ty-y, tx-x);
  spawnBullet(x,y,Math.cos(ang)*speed,Math.sin(ang)*speed,7,'boss',6);
}
function homing(x,y,target,speed){
  spawnBullet(x,y, (target.x - x)/100 * speed, (target.y - y)/100 * speed, 8, 'boss', 9);
}

// summon minion
function summonMinion(){
  enemies.push({
    x: boss.x + (Math.random()-0.5)*30,
    y: boss.y + boss.r + 6,
    vx:0, vy:0,
    speed: 90, // pixels/sec
    w:36, h:36, hp:30, melee:true
  });
}

// Boss update (integrated with phase2, laser, minions)
function bossUpdate(dt){
  boss.time += dt;
  // simple horizontal movement
  boss.x += boss.vx * dt;
  if(boss.x < boss.r + 20){ boss.x = boss.r + 20; boss.vx *= -1; }
  if(boss.x > W - boss.r - 20){ boss.x = W - boss.r - 20; boss.vx *= -1; }

  // change phase by health
  const hpPct = boss.hp / boss.maxHp;
  boss.phase = hpPct > 0.6 ? 1 : hpPct > 0.33 ? 2 : 3;

  // base firing patterns
  if(boss.phase === 1){
    if(Math.floor(boss.time * 10) % 12 === 0 && (boss.time - dt) * 10 % 12 > (boss.time * 10) % 12 - 1){
      radial(boss.x, boss.y, 12, 120);
    }
  } else if(boss.phase === 2){
    if(Math.floor(boss.time * 20) % 6 === 0){
      spiral(boss.x, boss.y, boss.time*8, 8, 180);
    }
    if(Math.random() < dt * 1.2){
      aimed(boss.x, boss.y, player.x, player.y, 220);
    }
  } else {
    if(Math.floor(boss.time * 8) % 8 === 0){ radial(boss.x, boss.y, 20, 160); }
    if(Math.random() < dt * 2.0){ homing(boss.x, boss.y, player, 140); }
  }

  // Phase 2 trigger - once hp <= 50%
  if(!boss.phase2 && boss.hp / boss.maxHp <= 0.5){
    boss.phase2 = true;
    boss.vx *= 1.2;
    // make the boss a bit more aggressive in phase 2
  }

  // timer for lasers (seconds)
  boss._sinceLastLaser += dt;

  // Phase 2 minion summon
  if(boss.phase2){
    if(performance.now() - boss.lastSummon > boss.summonCooldown){
      summonMinion(); summonMinion();
      boss.lastSummon = performance.now();
    }
    if(!boss.laserActive && boss._sinceLastLaser >= boss.laserCooldown && Math.random() < 0.6){
      startLaser();
    }
  } else {
    // small chance to laser in phase 1
    if(!boss.laserActive && boss._sinceLastLaser >= boss.laserCooldown * 1.8 && Math.random() < 0.06){
      startLaser();
    }
  }

  // update laser
  if(boss.laserActive){
    boss.laserTimer += dt;
    // after windup, laser deals damage if player in beam
    if(boss.laserTimer > boss.laserWindup){
      const ang = laser.ang;
      const dx = player.x - boss.x, dy = player.y - boss.y;
      const along = dx * Math.cos(ang) + dy * Math.sin(ang);
      const perp = Math.abs(-dx * Math.sin(ang) + dy * Math.cos(ang));
      if(along > 0 && perp < 18 * laser.scale){
        player.hp -= 10 * dt; // continuous damage
      }
    }
    if(boss.laserTimer > boss.laserDuration + boss.laserWindup){
      stopLaser();
    }
  }

  // death
  if(boss.hp <= 0 && boss.alive){
    boss.alive = false;
    // small effect is drawn by draw()
  }
}

// Start/stop laser
function startLaser(){
  boss.laserActive = true;
  boss.laserTimer = 0;
  boss._sinceLastLaser = 0;
  laser.ang = Math.atan2(player.y - boss.y, player.x - boss.x);
}
function stopLaser(){
  boss.laserActive = false;
  boss.laserTimer = 0;
  boss._sinceLastLaser = 0;
}

// --- Update loop (player, bullets, enemies) ---
function update(dt){
  // player movement
  let moveX = 0;
  if(keys['a']) moveX -= 1;
  if(keys['d']) moveX += 1;
  player.vx = lerp(player.vx, moveX * player.speed, 0.16);

  // jump: higher jump
  if((keys['w'] || keys[' ']) && player.onGround){
    player.vy = -700; // higher jump
    player.onGround = false;
  }

  // gravity
  player.vy += 1200 * dt;
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  // ground + platform collisions for player
  player.onGround = false;
  const groundY = H - 60;
  if(player.y + player.h/2 > groundY){
    player.y = groundY - player.h/2; player.vy = 0; player.onGround = true;
  }
  for(const p of platforms){
    if(player.x > p.x - 20 && player.x < p.x + p.w + 20){
      if(player.y + player.h/2 > p.y && player.y + player.h/2 < p.y + 20 && player.vy > 0){
        player.y = p.y - player.h/2; player.vy = 0; player.onGround = true;
      }
    }
  }
  player.x = clamp(player.x, 30, W-30);

  // sword handling
  if(mouse.down){
    if(!sword.sweeping){ sword.sweeping = true; sword.timer = 0; }
    sword.timer += dt;
  } else { sword.sweeping = false; sword.timer = 0; }

  // boss
  if(boss.alive) bossUpdate(dt);

  // bullets movement
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if(b.owner === 'boss' && b.life > 8){
      const ang = Math.atan2(player.y - b.y, player.x - b.x);
      const sp = Math.hypot(b.vx, b.vy);
      const desiredVx = Math.cos(ang) * sp;
      const desiredVy = Math.sin(ang) * sp;
      b.vx = lerp(b.vx, desiredVx, 0.06);
      b.vy = lerp(b.vy, desiredVy, 0.06);
    }
    b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
    if(b.life <= 0 || b.x < -50 || b.x > W+50 || b.y < -50 || b.y > H+50) bullets.splice(i,1);
  }

  // bullet collisions with player
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if(b.owner === 'boss'){
      const dx = player.x - b.x, dy = player.y - b.y;
      const rad = Math.hypot(dx,dy);
      if(rad < (b.size + Math.max(player.w, player.h)/2 - 4)){
        player.hp -= 6;
        bullets.splice(i,1);
        player.vx += dx/rad * -120;
      }
    }
  }

  // sword hitting boss
  if(sword.sweeping && boss.alive){
    const aimAng = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    const phase = (sword.timer % sword.swingTime) / sword.swingTime;
    const halfArc = sword.arc/2;
    const currentAngle = aimAng - halfArc/2 + halfArc * phase;
    const dx = boss.x - player.x, dy = boss.y - player.y, d = Math.hypot(dx,dy);
    if(d < sword.range + boss.r){
      const angToBoss = Math.atan2(dy,dx);
      let diff = Math.abs(((angToBoss - currentAngle) + Math.PI) % (Math.PI*2) - Math.PI);
      if(diff < 0.55){
        if(!sword._lastHitTime || performance.now() - sword._lastHitTime > sword.cooldown*1000){
          sword._lastHitTime = performance.now();
          boss.hp -= 12;
          boss.x += Math.cos(currentAngle) * 6;
          for(let i=0;i<6;i++){
            const a = currentAngle + (Math.random()-0.5)*0.8;
            spawnBullet(boss.x, boss.y, Math.cos(a)*(60+Math.random()*80), Math.sin(a)*(60+Math.random()*80), 3, 'player', 0.5);
          }
        }
      }
    }
  }

  // boss contact
  const dxBP = boss.x - player.x, dyBP = boss.y - player.y;
  if(Math.hypot(dxBP,dyBP) < boss.r + 20){
    player.hp -= 0.8;
  }

  // clamp hp
  player.hp = clamp(player.hp, 0, player.maxHp);
  boss.hp = clamp(boss.hp, 0, boss.maxHp);

  // update enemies (minions)
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    // apply gravity
    e.vy += 1200 * dt;
    e.x += e.vx * dt; e.y += e.vy * dt;
    // ground & platform collisions
    if(e.y + e.h/2 > groundY){ e.y = groundY - e.h/2; e.vy = 0; }
    for(const p of platforms){
      if(e.x > p.x-20 && e.x < p.x+p.w+20){
        if(e.y + e.h/2 > p.y && e.y + e.h/2 < p.y + 20 && e.vy > 0){ e.y = p.y - e.h/2; e.vy = 0; }
      }
    }
    // simple AI: move toward player
    const dx = player.x - e.x, dy = player.y - e.y;
    const d = Math.hypot(dx,dy);
    if(d > 6){ e.vx = (dx / d) * e.speed; } else e.vx = 0;
    if(d < 36){ player.hp -= 12 * dt; }
    if(e.hp <= 0){ enemies.splice(i,1); }
  }

  // death detection: reload after a short delay (handled in draw)
}

// --- Draw ---
function draw(){
  ctx.clearRect(0,0,W,H);

  // background stars
  for(let i=0;i<40;i++){
    const sx = (i*97) % W;
    const sy = ((i*47) + (performance.now()/60|0)) % H;
    ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(sx,sy,1.2,1.2);
  }

  // ground
  ctx.fillStyle = '#071a29'; ctx.fillRect(0,H-60,W,60);

  // platforms
  ctx.fillStyle = '#0d2a3a';
  for(const p of platforms) ctx.fillRect(p.x, p.y, p.w, p.h);

  // boss (draw sprite if available, else shape)
  if(boss.alive){
    if(bossImg && bossImg.complete && bossImg.naturalWidth){
      const sizeW = boss.r * 2;
      const sizeH = boss.r * 1.7;
      ctx.drawImage(bossImg, boss.x - sizeW/2, boss.y - sizeH/2, sizeW, sizeH);
    } else {
      const g = ctx.createLinearGradient(boss.x - boss.r, boss.y - boss.r, boss.x + boss.r, boss.y + boss.r);
      g.addColorStop(0,'#6b2d2d'); g.addColorStop(1,'#ff8b5e');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.ellipse(boss.x,boss.y,boss.r,boss.r*0.85,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#2b0d0d'; ctx.beginPath(); ctx.ellipse(boss.x-18,boss.y-6,10,8,0,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(boss.x+18,boss.y-6,10,8,0,0,Math.PI*2); ctx.fill();
    }
    ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = '16px system-ui'; ctx.textAlign='center'; ctx.fillText('Israel Coffee', boss.x, boss.y - boss.r - 18);
  } else {
    ctx.fillStyle = 'rgba(255,220,80,0.14)'; ctx.beginPath(); ctx.ellipse(boss.x,boss.y, boss.r*1.6, boss.r*1.2,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'white'; ctx.font='30px system-ui'; ctx.textAlign='center'; ctx.fillText('DEFEATED', boss.x, boss.y);
  }

  // bullets
  for(const b of bullets){
    if(b.owner === 'boss'){
      ctx.fillStyle = 'rgba(255,90,90,0.98)';
      ctx.beginPath(); ctx.arc(b.x,b.y,b.size,0,Math.PI*2); ctx.fill();
    } else {
      ctx.fillStyle = 'rgba(180,220,255,0.98)'; ctx.beginPath(); ctx.arc(b.x,b.y,b.size,0,Math.PI*2); ctx.fill();
    }
  }

  // draw player (sprite or rectangle)
  if(playerImg && playerImg.complete && playerImg.naturalWidth){
    const pw = player.w * 1.6, ph = player.h * 1.6;
    ctx.drawImage(playerImg, player.x - pw/2, player.y - ph/2, pw, ph);
  } else {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = '#a8d3ff'; ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
    ctx.fillStyle = '#f7f7f7'; ctx.beginPath(); ctx.arc(10, -player.h/2 + 8, 8, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // sword arc (visual)
  if(sword.sweeping){
    const aimAng = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    const halfArc = sword.arc/2;
    const phase = (sword.timer % sword.swingTime) / sword.swingTime;
    const currentAngle = aimAng - halfArc/2 + halfArc * phase;
    ctx.save(); ctx.translate(player.x, player.y);
    ctx.strokeStyle = 'rgba(255,240,200,0.12)'; ctx.lineWidth = 36; ctx.beginPath(); ctx.arc(0,0, sword.range, currentAngle - 0.45, currentAngle + 0.45); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,220,120,0.4)'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0,0, sword.range, currentAngle - 0.45, currentAngle + 0.45); ctx.stroke();
    const tipX = Math.cos(currentAngle) * sword.range, tipY = Math.sin(currentAngle) * sword.range;
    ctx.fillStyle = 'rgba(255,240,180,0.95)'; ctx.beginPath(); ctx.arc(tipX, tipY, 8, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  } else {
    ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.arc(mouse.x, mouse.y, 8, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.arc(mouse.x, mouse.y, 18, 0, Math.PI*2); ctx.stroke();
  }

  // draw minions
  for(const e of enemies){
    if(gubbyImg && gubbyImg.complete && gubbyImg.naturalWidth){
      ctx.drawImage(gubbyImg, e.x - e.w/2, e.y - e.h/2, e.w, e.h);
    } else {
      ctx.fillStyle='rgba(200,180,120,0.95)'; ctx.fillRect(e.x - e.w/2, e.y - e.h/2, e.w, e.h);
    }
  }

  // laser visual
  if(boss.laserActive){
    const ang = laser.ang;
    ctx.save(); ctx.translate(boss.x, boss.y); ctx.rotate(ang);
    const t = boss.laserTimer; const wind = Math.min(1, t / boss.laserWindup);
    ctx.fillStyle = 'rgba(255,60,60,' + (0.18 + 0.5*wind) + ')';
    ctx.fillRect(0, -10*laser.scale, W, 20*laser.scale);
    ctx.restore();
  }

  // HUD
  document.getElementById('playerHP').style.width = (player.hp / player.maxHp * 100) + '%';
  document.getElementById('bossHP').style.width = (boss.hp / boss.maxHp * 100) + '%';
  ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='14px system-ui'; ctx.textAlign='left'; ctx.fillText('HP: ' + Math.round(player.hp), 12, 20);

  // boss status message
  if(!boss.alive){
    ctx.fillStyle='rgba(180,255,200,0.9)'; ctx.font='18px system-ui'; ctx.textAlign='center'; ctx.fillText('You defeated Israel Coffee! Nice!', W/2, 50);
  }

  // death handling: show and reload once
  if(player.hp <= 0){
    if(!window._playerDead){
      window._playerDead = true;
      ctx.fillStyle='rgba(255,120,120,0.95)'; ctx.font='36px system-ui'; ctx.textAlign='center'; ctx.fillText('YOU DIED', W/2, H/2);
      setTimeout(()=> location.reload(), 900);
    } else {
      ctx.fillStyle='rgba(255,120,120,0.95)'; ctx.font='36px system-ui'; ctx.textAlign='center'; ctx.fillText('YOU DIED', W/2, H/2);
    }
  }
}

// --- Main loop (controlled) ---
function loop(now){
  if(!running) return;
  if(!lastTime) lastTime = now;
  const dt = Math.min(1/30, (now - lastTime)/1000);
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// --- Start button logic ---
const startBtn = document.getElementById('startBtn');
const mainMenu = document.getElementById('mainMenu');
startBtn.addEventListener('click', () => {
  mainMenu.style.display = 'none';
  running = true;
  lastTime = performance.now();
  // focus canvas so mouse wheel / input works on some browsers
  canvas.focus && canvas.focus();
  requestAnimationFrame(loop);
});

// Also allow pressing Enter to start
window.addEventListener('keydown', (e) => {
  if(!running && (e.key === 'Enter' || e.key === ' ')){ startBtn.click(); }
});

// Start with menu visible; game only runs after pressing Start.

</script>
</body>
</html>
